#!/bin/bash

#author: Alejandro Erickson
if [ -d inrflow.$$.d ]; then
    echo "Directory inrflow.$$.d exists.  Try again."
    exit 1;
fi

cat <<EOF 

This script will clean your build directory and compile INRFlow.  If
you supply a file with a list of arguments to inrflow, the arguments
in the file will be tested, and otherwise those generated by
./gen_test_args.sh.

Job log file at inrflow.$$.d/test.log and STDOUT of each job at inrflow.$$.d/n.out.

Do you wish to continue? RET / CTRL-c|n|N|q|Q

EOF

read response
if [ "$response" = "n" ] || [ "$response" = "N" ] || [ "$response" = "q" ] || [ "$response" = "Q" ] 
then
    exit
fi

(cd ../ && make clean)

echo "Debug flags on? RET / n|N"
read response
if [ "$response" = "n" ] || [ "$response" = "N" ]
then
    (cd ../ && make all)
else    
    (cd ../ && make all CFLAGS="-DDEBUG -g")
fi

mkdir inrflow.$$.d && cp .././build/bin/inrflow inrflow.$$.d/ && cp ../pretty_data.tex inrflow.$$.d/ && cp ../stats_only.tex inrflow.$$.d/ && cp inrflow.conf inrflow.$$.d/ && cd inrflow.$$.d

if [ $? -ne 0 ]; then
    echo "failed to setup working directory"
    exit 1
fi

cat<<EOF

Working directory:
EOF

pwd

cat<<EOF

EOF

if [ $# -ge 1 ]
then
    TEST_ARGS="cat ../$1"
else
    TEST_ARGS=".././gen_test_args.sh"
fi

# some help from http://stackoverflow.com/questions/1570262/shell-get-exit-code-of-background-process
handle_chld() {
		#echo pids are ${pids[@]}
    local tmp=() ###temporary storage for pids that haven't finished
		#for each pid that hadn't finished since the last trap
    for((i=0;i<${#pids[@]};++i)); do
				#if this pid is still running
        if [[ $(ps -p ${pids[i]} -o pid=) ]]
				then
						tmp+=(${pids[i]}) ### add pid to list of pids that are running
				else
            wait ${pids[i]} ### put the exit code of this pid into $?
						if [ "$?" != "0" ] ### if the exit code $? is non-zero
						then
								#kill all remaning processes
								for((j=0;j<${#pids[@]};++j))
								do
										if [[ $(ps -p ${pids[j]} -o pid=) ]]
										then
												echo killing child processes of ${pids[j]}
												pkill -P ${pids[j]}
										fi
								done
								cat ${pids[i]}.out
								#print things to the terminal here
								echo "FAILED process ${pids[i]} args:	`cat ${pids[i]}.meta`"
								exit 1
						else
								echo "FINISHED process ${pids[i]} args: `cat ${pids[i]}.meta`"
						fi	 
        fi
    done
		#update list of running pids
    pids=(${tmp[@]})
}
# set this to monitor SIGCHLD
set -o monitor
# call handle_chld() when SIGCHLD signal is triggered
trap "handle_chld" CHLD

# not using xargs because we want to record PIDs

${TEST_ARGS} | \
		while read A; do
				(./inrflow ${A}) > $!.out &
				pids+=($!)
				#echo _tmpargs${pids[${#pids[@]}-1]}
				echo $A > ${pids[${#pids[@]}-1]}.meta
				echo "STARTED process ${pids[${#pids[@]}-1]} args: `cat ${pids[${#pids[@]}-1]}.meta`"
		done
echo "Every process started.  Now waiting on PIDS:"
echo ${pids[@]}
wait ${pids[@]} ###wait until every process is finished (or exit in the trap)
